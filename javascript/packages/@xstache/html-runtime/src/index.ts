class StringBuffer {
    parts: string[] = [];

    public push(part: string) {
        if (typeof part !== "string") {
            throw new Error(`Expected string, got ${typeof part}`);
        }
        this.parts.push(part);
    }

    public flush() {
        const result = this.parts.join("");
        this.parts = [];
        return result;
    }
}

class Context {
    constructor(
        private readonly data: any,
        private readonly parent: Context | null = null,
    ) {}

    public value(keys: string[]) {
        let found = true;
        let value = this.data;
        for (const key of keys) {
            const next = value ? value[key] : undefined;
            if (next) {
                value = next;
            } else {
                found = false;
                break;
            }
        }
        return found ? value : this.parent?.value(keys);
    }

    public section(
        keys: string[],
        implementation: (context: Context) => any,
    ) {
        const data = this.value(keys);
        if (!data) {
            return undefined;
        }
        const render = (data: any) => implementation(new Context(data, this));
        return Array.isArray(data) ? data.forEach(render) : render(data);
    }

    public element(
        name: string,
        attributes: Record<string, any>,
        implementation: () => void | undefined,
        buffer: StringBuffer,
    ) {
        buffer.push(`<${name}`);
        for (const key in attributes) {
            let attribute = ` ${key}`;
            const value = attributes[key];
            if (value) {
                // TODO: Allow value to be a function implementation that accepts a context and
                //     buffer. That's necessary to support sections, inverted sections, etc. as
                //     attribute values.
                const stringified = this.coerceToString(value);
                const escaped = this.escape(stringified);
                attribute += `="${escaped}"`;
            }
            buffer.push(attribute);
        }
        // Self-closing tag's have no children implementation.
        if (!implementation) {
            buffer.push(" />");
            return;
        }
        buffer.push(">");
        implementation();
        buffer.push(`</${name}>`);
    }

    private coerceToString(value: any) {
        if (!value) {
            return "";
        } else if (typeof value === "string") {
            return value;
        } else {
            return value.toString();
        }
    }

    private escape(input: string) {
        return input
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }
}

/** Signature of the function generated by the `@xstache/html` compiler. */
export type Implementation = (context: Context, buffer: StringBuffer) => void;

export class Template {
    constructor(private readonly implementation: Implementation) {}

    public render(data: any) {
        const context = new Context(data);
        const buffer = new StringBuffer();
        this.implementation(context, buffer);
        return buffer.flush();
    }
}
